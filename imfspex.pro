PRO imfspex,infile,outfile,order,psffile,lamfile,OMAPFILE=omapfile,LMAPFILE=lmapfile,WAVSAMP=wavsamp,UNCFILE=uncfile,BMFILE=bmfile,RESFILE=resfile,SKYFILE=skyfile,REGRID=regrid,POSITION=position,FOVRANGE=fovrange,SPOT=spot,RANGE=range,DEGREE=degree,REPORT=report,DIAG=diag,PLOT=plot,_extra=e

; 18 Feb 13 fixed a bug that resets vector position to scalar when adding offset
; 18 Aug 12 not combining spectra if second has no data - prevents a crash
;  9 Mar 12 added range keyword, previously just defaulted to 1.5 pixels
; 20 Feb 12 offsetting bonus position if position set
;           saving extracted bonus position as EXTPOSB in output FITS header
; 18 Feb 12 explicitly passing degree and, if spot set, colrange
;           added resfile and skyfile keywords to save residual and sky images
; 14 Dec 11 added fovrange keyword
;  7 Dec 11 added regrid keyword, removed noregrid keyword
;           the default is now NOT TO REGRID
; 28 Nov 11 now calling mk_pos.pro to find and write the extracted RA and DEC
; 25 Aug 09 updated comments
; 22 Aug 09 returned pillow function to older form
; 20 Aug 09 modified pillow function to have subpix+1 values
; 17 Aug 09 added plot keyword to call spplot and display the result
; 10 Aug 09 now using the nod 2 trace coefficients where appropriate
; 21 Jul 09 made diag a keyword, if outfile='nosave' then nothing saved to disk
; 20 Jul 09 made omap, lmap into keywords, dropped module
; 16 Jul 09 added pillow function, defined based on subpix
;  7 Jul 09 added position keyword
; 29 Jun 09 modified to handle 3-plane input, now required for imspex call
; 22 Jun 09 upgraded for new Version 2
;           now reads trace coefficients in PSF file for both nods, keeps nod 0
; 23 May 07 added a NOREGRID keyword to turn off the call to spgridspline
;  1 May 07 can now extract multiple orders from one image
;           final spectrum now regridded here, not in imspex 
; 26 Apr 07 added _extra keyword to pass to imspex
; 22 Apr 07 created - not yet tested for multiple order extraction
;
; imfspex basically serves as a wrapper for imspex (cf)
; imfspex reads several images and calls imspex
;   imspex extracts a spectrum from a spectral image
; imfspex can extract more than order by calling imspex multiple times
;
; INPUT
;   infile   - a 2D FITS file with the spectral image
;   outfile  - name of the output spectral FITS file
;   order    - a vector of orders to extract (or a scalar for one)
;   psffile  - name of the PSF file - if one order to be extracted, can be 2D
;              otherwise, needs to have one plane per order, in order
;              must contain trace coeff., subpix, and centcol in the header
;              must have minorder if more than one order extracted
;   lamfile  - the file containing wavelengths and orders
;   omapfile - keyword - the name of the order map FITS file
;   lmapfile - keyword - the name of the wavelength map FITS file
;   wavsamp  - optional keyword- the name of the wavsamp file
;              if provided, omapfile and lmapfile are not used
;              instead, they are generated by calling mk_map to read wavsamp
;   uncfile  - optional keyword to define error plane/uncertainty file
;   bmfile   - optional keyword to define bmask file
;   regrid   - keyword to regrid using calls to spregrid
;   noregrid - keyword to turn off call to spgridspline - NO LONGER SUPPORTED
;   position - keyword giving positions of known sources
;              if no other sources requested, positions finders not called
;   fovrange - number of pixels to L and R of nominal nod position to search
;              NOTE - fovrange overrides colrange and spot
;              packaged as colrange keyword in imspex call
;   spot     - specified approximate position of source(s)
;              expanded to colrange (spot +/- range pixels) and passed to imspex
;   range    - for use with spot, range to search to each side (DEFAULT=1.5)
;   degree   - keyword, degree of polynomial for background fit - for exspecrow
;              if not specified, set to -1 before passing on to imspex
;   report   - print extracted positions to file 'report.txt'
;   diag     - diagnostic keyword
;
;   _extra   - used to pass the following:  colrange, nfind
;
; NOTE:  Either omap and lmap or wavsamp must be specified

; OUTFILE    - spectral fits data written to outfile
;   resfile  - residual image written to residual file
;   skyfile  - sky image written to sky file
;
; sample calls:
;
; imfspex,'hr6348.28a1.0400.im.fits','nosave',1,'cal/psf_0_18v1.fits','cal/sl.lam.fits',wavsamp='cal/b0_wavsamp_18.tbl',pos=9.416
;
; imfspex,'hr6348.20a1.0400.im.fits','hr6348.t4.sp.fits',1,'psf_sl_s17.0.fits','sl.lam.fits',wavsamp='b0_wavsamp_15.tbl',uncfile='hr6348.20a1.0400.fu.fits',pos=9.60
;
; imfspex,'~/irsdata/local_15/SL/extract/alwscl3.a1.0408.ic.fits','alwscl3.test.sp.fits',1,'psf_s15_10.fits','sl.lam.fits',wavsamp='b0_wavsamp_15.tbl'
;
; imfspex,'/home/ioc/campaign_s15/IRS_070_15/SL/extract/hd173511_20.a1.0400.ic.fits','hd173test.sp.fits',1,'psf_s15_10d.fits','sl.lam.fits',wavsamp='b0_wavsamp_15.tbl'

; read input files - load image as a 3-plane array
;   from infile, load spectral image 
;   if uncfile declared, it's the second plane, else, load with 1's
;   if bmfile declared, it's the third plane, else, load with 0's

image=readfits(infile,imhdr,/silent)
sz=size(image) & ncol=sz[1] & nrow=sz[2]
if (keyword_set(uncfile) ne 0) then error=readfits(uncfile,/silent) $
  else error=fltarr(ncol,nrow)+1.0
if (keyword_set(bmfile) ne 0) then bmask=readfits(bmfile,/silent) $
  else bmask=fltarr(ncol,nrow)
if (sz[0] ne 3) then image = [[[image]],[[error]],[[bmask]]]

; determine module and FOV from FITS header 
; determine nominal position from FOV

module  = sxpar(imhdr,'CHNLNUM')
fov     = sxpar(imhdr,'FOVID') ; this FOV does not account for obs in other slit
nominal = nominalpos(fov)      ; this position NOT used to update FITS header

; check additional keywords

if (keyword_set(diag) eq 0) then diag=0
if (n_elements(degree) eq 0) then degree=-1
if (keyword_set(report) ne 0) then openw,fr,'report.txt',/get_lun,/append

; from lamfile, load wavelength-order information from FITS files

lamorder=readfits(lamfile,/silent)

; check number or orders to extract

norder=n_elements(order)

; load PSF file
; call psfheader to read several parameters from PSF FITS header

psfcube=readfits(psffile,psfhdr,/silent)

tracecoeffs=psfheader(psfhdr,subpix,centcol,minorder)

; choose the trace coefficients appropriate to the FOVID

idx=0
if (fov eq '27' or fov eq '33' or fov eq '39' or fov eq '45') then idx=1

tracecoeffs=reform(tracecoeffs[*,idx,*]) ; idx=0 for nod 1, 1 for nod 2

; check len, number of orders to extract from image
; if order=[2,3] set the offsets to properly extract bonus order
; otherwise zero it for use in loop through orders below

len=n_elements(order)

if (len eq 2) then begin
  offset=[0.0,0.0] ; zero offsets, reset in next if block where needed
  if (order[0] eq 2 and order[1] eq 3) then begin
    if (fov ge 32 and fov le 34) then offset=[0,-0.082]
    if (fov ge 44 and fov le 46) then offset=[0,0.088]
  endif
endif else offset = findgen(len) - findgen(len)

; define pillow function, intrapixel responsivity, based on subpix
; if subpix=10, then SL data, else LL data - THIS IS A TEMPORARY SOL'N

if (subpix eq 10) then $
  pillow=[0.65,0.8,0.9,0.95,1.0,1.0,0.95,0.9,0.8,0.65] $
  else pillow = fltarr(subpix)+1.0
pillow=subpix*pillow/total(pillow)

; check minorder and load if needed

if  (minorder eq 0) then begin
  if (norder eq 0) then minorder=order else minorder=0
endif

; load order and wavelength maps
; if WAVSAMP parameter set, call mk_map with the FILENAME parameter
; otherwise, load the maps as simple FITS images

if (keyword_set(wavsamp) ne 0) then begin
  mk_map,module,omap,lmap,pmap,wavsamp 
endif else begin
  if (keyword_set(omapfile) eq 0 or keyword_set(lmapfile) eq 0) then begin
    print,'Error in imfspex.  Must specify order & wavelength or wavsamp file.'
    stop
  endif else begin
    omap=readfits(omapfile,/silent)
    lmap=readfits(lmapfile,/silent)
  endelse
endelse

; expand spot(s) to colrange(s), range will default to +/- 1.5 pix

nspot=n_elements(spot)
for n=0,nspot-1 do begin
  if (keyword_set(range) eq 0) then range=1.5
  if (n_elements(colrange) lt 2) then $
    colrange=[spot[n]-range,spot[n]+range] else $
    colrange=[ [colrange] , [spot[n]-range,spot[n]+range] ]
endfor

; loop through requested orders

sz=size(psfcube)

for i=0,len-1 do begin

; set order to pass to imspex (ord)

  ord=order[i]

; pick plane of PSF cube and row of tracecoeffs array to use

  if (sz[0] eq 2) then begin
    psf=psfcube
    tracecoeff=tracecoeffs 
  endif else begin
    plane = ord-minorder
    psf=reform(psfcube[*,*,plane])
    tracecoeff=reform(tracecoeffs[*,plane])
  endelse

; apply offsets to position vector (if set) - these are removed at end of loop

  if (keyword_set(position) ne 0) then position += offset[i]

; call imspex  - syntax depends on whether fovrange and spot keywords set

  if (keyword_set(fovrange) eq 0) then begin

    if (n_elements(spot) eq 0) then begin

      sp=imspex(image,ord,omap,lmap,tracecoeff,psf,subpix,centcol,$
         degree=degree,pillow=pillow,inpos=position,outpos=outpos,$
         residual=residual,sky=sky,diag=diag,_extra=e)

    endif else begin

      sp=imspex(image,ord,omap,lmap,tracecoeff,psf,subpix,centcol,$
         degree=degree,pillow=pillow,inpos=position,outpos=outpos,$
         colrange=colrange,residual=residual,sky=sky,diag=diag,_extra=e)

    endelse 
  endif else begin

;   set searchrange based on nominal position

    searchrange=[nominal-fovrange,nominal+fovrange]

    sp=imspex(image,ord,omap,lmap,tracecoeff,psf,subpix,centcol,degree=degree,$
       pillow=pillow,inpos=position,outpos=outpos,colrange=searchrange,$
       residual=residual,sky=sky,diag=diag,_extra=e)

  endelse
 
  npsf=n_elements(sp[0,0,*])

; regrid spectrum to standard wavelength grid if regrid keyword set
; first need to reduce lamorder array to order in question

  if (keyword_set(regrid) ne 0) then begin

    idx=where(lamorder[1,*] eq ord)
    if (max(idx) gt -1) then lamdata=lamorder[*,idx] else begin
      print,'Error in imfspex. No data in requested order'
    endelse

; regrid source by source using spregrid, new version of spgridspline

    if (npsf eq 1) then spec=spregrid(sp,lamdata) else begin
      for n=0,npsf-1 do begin
        plane=spregrid(reform(sp[*,*,n]),lamdata)
        if (n eq 0) then spec=plane else spec=[[[spec]],[[plane]]]
      endfor
    endelse

  endif else spec=sp ; DEFAULT - no regridding

; print a report if requested, giving order and positions extracted

  if (keyword_set(report) ne 0) then $
    printf,fr,outfile,' ',order[i],outpos,format='(a30,a1,i3,10(f8.3))'

; update spectrum array and positions output by imspex
; note, only update positions for first order extracted

  if (i eq 0) then begin
    spectrum=spec 
    actualpos=outpos
  endif else begin
    if (n_elements(spec) gt 1) then spectrum=[[spectrum],[spec]]
    actualposb=outpos
  endelse

; reset position input for imspex (if set) by removing offsets added above

  if (keyword_set(position) ne 0) then position -= offset[i]

endfor

; reorder planes of spectral data by distance from nominal to actual position

if (npsf gt 1) then begin
  distance=abs(actualpos-nominal)
  idx=sort(distance)

  dummy=spectrum
  for n=0,npsf-1 do spectrum[*,*,n] = dummy[*,*,idx[n]]
endif

; set xap, =1 if source in the other aperture

testorder=min(order)
if (testorder eq 3) then testorder=2
xap=0
if (fov ge 26 and fov le 28 and testorder eq 2) then xap=1 ; nominally SL1
if (fov ge 32 and fov le 34 and testorder eq 1) then xap=1 ; nominally SL2
if (fov ge 38 and fov le 40 and testorder eq 2) then xap=1 ; nominally LL1
if (fov ge 44 and fov le 46 and testorder eq 1) then xap=1 ; nominally LL2

; write results to a spectral FITS file, one per source

for n=0,npsf-1 do begin

; create output file name if examining second spectrum or later

  if (n eq 0) then outfilename=outfile else begin
    split0=strsplit(outfile,'/',/extract)
    n0=n_elements(split0)
    split1=strsplit(split0[n0-1],'.',/extract)
    n1=n_elements(split1)
    target=split1[0]+'_'+string(n,format='(i1)')
    outfilename=''
    if (n0 gt 1) then for k=0,n0-2 do outfilename=outfilename+split0[k]+'/'
    outfilename=outfilename+target
    if (n1 gt 1) then for k=1,n1-1 do outfilename=outfilename+'.'+split1[k]
  endelse

; update FITS header with position (actualpos)
; will eventually want to add more lines to document the extraction

  sphdr=imhdr
  mk_pos,actualpos[n],sphdr,xap=xap
  if (n_elements(actualposb) gt 0) then $
    sxaddpar,sphdr,'EXTPOSB',actualposb[n],$
    ' [pix] Position of bonus order spectrum in row 0',after='EXTPOS '

; if plot keyword set, the call spplot

  if (keyword_set(plot) ne 0) then spplot,spectrum[*,*,n],_extra=e

; write output FITS files

  if (outfile ne 'nosave') then $
    wr_spfits,outfilename,spectrum[*,*,n],-1,FITS_hdr=sphdr,/quiet
  print,'printed ',outfilename

  imhdr=sphdr
  sxaddpar,imhdr,'NAXIS1',ncol
  sxaddpar,imhdr,'NAXIS2',nrow

  if (keyword_set(resfile) ne 0) then begin
    print,'Hello resfile'
    writefits,resfile,residual,imhdr
  endif
  if (keyword_set(skyfile) ne 0) then writefits,skyfile,sky,imhdr

endfor

if (keyword_set(report) ne 0) then free_lun,fr
END
